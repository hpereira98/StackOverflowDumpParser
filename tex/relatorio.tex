%% RELATÓRIO DO PROJETO EM C DE LI3

\documentclass[a4paper, 11pt, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{multicol}

%% DEFINIÇÃO DOS SNIPPETS EM C
\usepackage{listings}
\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  morekeywords={GArray,GHashTable,GTree,STR_pair,LONG_list,LONG_pair,USER,TCD_community, User,Post, Tag},keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{gray},
  stringstyle=\color{orange},
}

\lstset{escapechar=@,style=customc}


%%RELATÓRIO

\begin{document} 

\begin{titlepage}


	\centering 
	
	\scshape
	
	\vspace*{\baselineskip}
	
	
	\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
	\rule{\textwidth}{0.4pt}
	
	\vspace{0.75\baselineskip}
	
	{\LARGE RELATÓRIO DO PROJETO EM C} 
	
	\vspace{0.75\baselineskip} 
	
	\rule{\textwidth}{0.4pt}\vspace*{-\baselineskip}\vspace{3.2pt}
	\rule{\textwidth}{1.6pt}
	
	\vspace{2\baselineskip}
	
	Laboratórios de Informática III
	
	\vspace*{3\baselineskip}
	
	Grupo 24:
	
	\vspace{0.5\baselineskip}
	
	{\scshape\Large Henrique Pereira (a80261) \\ Pedro Moreira (a82364) \\ Pedro Ferreira (a81135) \\}
	
	\vspace{0.5\baselineskip}
	
	\textit{Universidade do Minho \\ Mestrado Integrado em Engenharia Informática}
	
	\vfill

	\includegraphics[width=40mm]{logoUM.jpg}

	\vspace{0.3\baselineskip}
	
	2018

\end{titlepage}

%% ÌNDICE

\tableofcontents
\lstlistoflistings

\newpage

%% INTRODUÇÃO

\section{Introdução}

No âmbito da unidade curricular \underline{Laboratórios de Informática III}, do 2º ano do Mestrado Integrado em Engenharia Informática, foi-nos proposta a realização de um projeto. Projeto este que consistia no desenvolvimento de um sistema capaz de processar ficheiros XML, armazenando as várias informações utilizadas pelo Stack Overflow (uma das comunidades de perguntas e respostas mais utilizadas atualmente por programadores em todo o mundo). Além disso, após o tratamento da informação, o sistema teria que ser capaz de responder eficientemente a um conjunto de interrogações (explicitado na secção \ref{queries}). Esta aplicação teria que ser obrigatoriamente desenvolvida em \textit{C}.

Ora, perante este enunciado, decidimos utilizar na estruturação do nosso sistema as definições da biblioteca \href{https://developer.gnome.org/glib}{GLib} (versão 2.56.1), mais propriamente as GHashTables, as GTrees e os GArrays (e respetivas funções). As estruturas por nós definidas serão apresentadas e justificadas na secção \ref{structs}.

O grupo decidiu organizar o trabalho, separando o código em diferentes ficheiros, isto é, um ficheiro para as estruturas por nós definidas e utilizadas (\textit{structPost.c},\textit{structTag.c},\textit{structTCD.c} e \textit{structUser.c}) e respetivos acessos (getters e setters, como forma de garantir o encapsulamento), um para o parser do ficheiro XML (\textit{load.c}), um para cada interrogação (\textit{query\_*.c}), um para as funções auxiliares (\textit{my\_funcs.c}) e outro para a \textit{main.c}. As funções de \textit{init} e \textit{clean} estão definidas no ficheiro \textit{structTCD.c}.

Um ponto fulcral deste trabalho é conciliar a eficiência com o encapsulamento, sem comprometer nenhum destes.

%% ESTRUTURAS

\newpage
\section{Estrutura}
\label{structs}

Para a realização do projeto, tivemos que definir vária estruturas de dados em \textit{C}, de maneira a respeitarmos o enunciado, no que toca aos tipos concretos e abstratos de dados. Foi-nos dada a seguinte definição abstrata de uma comunidade do Stack Overflow:

\begin{lstlisting}[caption=Definição da TAD\_community]
typedef struct TCD_community * TAD_community;
\end{lstlisting}

Assim sendo, tivemos como desafio criar a nossa própria definição concreta da comunidade. Após ponderarmos em grupo, tendo em conta as interrogações que nos apresentaram, a eficiência e o encapsulamento, decidimos organizar a nossa \textit{TCD\_community} da seguinte maneira (utilizando as definições da biblioteca GLib):
\begin{itemize}
\item Uma tabela de Hash para os Utilizadores
\item Uma árvore binária balanceada para os Posts
\item Uma tabela de Hash para acesso direto à data dos Posts pelo seu ID
\item Uma tabela de Hash para as Tags
\end{itemize}
\begin{lstlisting}[caption=Definição da TCD\_community]
struct TCD_community{
	GHashTable* user;
	GTree* post;
	GHashTable* postAux;
	GHashTable* tags;	
};
\end{lstlisting}

Por sua vez, definimos também uma estrutura para os Utilizadores, para os Posts e para as Tags, com o intuito de as "guardar" em cada elemento das tabelas/árvore acima descritas. De notar que o Utilizador cujo ID é -1 não foi incluído na nossa estrutura.

\begin{lstlisting}[caption=Definição de estruturas internas]
struct user{
	long id; // identificador do utilizador
	char* display_name; // username
	int n_posts; // numero total de posts
	int reputacao; // reputacao do utilizador
	char* short_bio; // descricao do utilizador 
	GArray* userPosts; // array dinamico com os posts do utilizador
};

struct post{
	long id; // id do post
	char* titulo; // titulo do post
	long owner_id; // id do criador do post
	int owner_rep; // reputacao do criador do post
	int type_id; // tipo do post
	long parent_id; // "pai" do post (se este for resposta)
	char* data; // data do post
	GArray* tags; // tags do post
	int score; // score do post
	int n_comments; // numero de comentarios do post
	int n_respostas; // numero de respostas do post (se este for pergunta)
};

struct tag{
	char* name; // nome da tag
	long id; // id da tag
};
\end{lstlisting}

A nossa decisão de utilizar as tabelas de Hash vai de encontro ao propósito de aceder diretamente à informação por nós pretendida (seja de um Utilizador ou de uma Tag), a partir de um ID. Porém, para os Posts, decidimos utilizar uma estrutura diferente, neste caso uma árvore binária balanceada, pois necessitávamos de uma ordem (neste caso cronológica) de recolha da informação dos Posts da estrutura. Assim, como é mais eficiente iterar numa árvore tendo em mente a sua ordenação, decidimos utilizar uma estrutura diferente. Além disso, desenvolvemos também duas estruturas auxiliares: uma tabela de Hash, contendo a data de cada Post (uma vez que lidamos variadas vezes com estes de forma cronológica), e uma estrutura \textit{postKey} apenas contendo a data e o ID do Post de forma a facilitar a sua inserção na árvore.

%% QUERIES
\newpage
\section{Interrogações e abordagem}
\label{queries}
Nesta secção, iremos explicitar a nossa abordagem às interrogações descritas no enunciado, mostrando algumas partes do código que achamos importante incluir de forma a facilitar a justificação da abordagem referida. Como o encapsulamento foi algo que sempre quisemos preservar ao longo do desenvolvimento do projeto, separamos os ficheiros de modo a que cada ficheiro \textit{query\_*.c} contém uma função auxiliar que será chamada no seio da função original da query definida no \textit{interface.h}.

\subsection{Info From Post}
A primeira interrogação tinha como objetivo definir uma função que retornasse o título do post e o nome do autor dado um ID de um Post. Se o Post for uma resposta, a função deverá retornar informações (título e utilizador) da pergunta correspondente. O resultado teria que ser um \textit{STR\_pair}, par de Strings definido no repositório que nos foi dado.

\begin{lstlisting}[caption=Query 1 - tipo função auxiliar]
STR_pair info_from_post_aux(GTree* com_post, GHashTable* com_postAux, GHashTable* com_user, long id);
\end{lstlisting}

Ora, isto foi bastante simples, uma vez que apenas foi necessário ir buscar o Post com o dado ID (ou, no caso desse Post ser uma resposta, ir buscar a respetiva pergunta) e o autor do mesmo (ou da pergunta, na situação referida) e, de seguida, colocar no \textit{STR\_pair} o título do Post e o nome do autor, como pretendido. Para fazer a procura na tabela de Hash utilizamos a função \textit{g\_hash\_table\_lookup}, dada pela \textit{GLib}.

\subsection{Top Most Active}
Na segunda interrogação, era-nos pedida uma função que criasse uma lista com os N utilizadores mais ativos, isto é, com o maior número de Posts. Essa lista seria, portanto, uma \textit{LONG\_list}.

Para tal, criamos um \textit{GArray} (array dinâmico definido na \textit{GLib}) para guardarmos todos os utilizadores presentes na respetiva tabela de Hash e para, depois, os ordenarmos mais facilmente pelo número de Posts com a função \textit{g\_array\_sort}.
\begin{lstlisting}[caption=Query 2 - tipo da função auxiliar]
LONG_list top_most_active_aux(GHashTable* com_user, int N);
\end{lstlisting}

Para iterarmos a tabela de Hash e colocarmos os utilizadores consoante o seu número de Posts, utilizamos as funções \textit{g\_hash\_table\_foreach} e as seguintes por nós definidas:
\begin{lstlisting}[caption= Query 2 - funções auxiliares]
int sortByNPosts(User* a,User *b){
	int nposts1 = getUserNPosts(*a);
	int nposts2 = getUserNPosts(*b);
	
	return nposts2-nposts1;
}

void appendUserToArray (gpointer key_pointer, gpointer user_pointer, gpointer info){	
	User user = (User)user_pointer;
	GArray* users = (GArray*)info;

	g_array_append_val(users,user);

}
\end{lstlisting}

\subsection{Total Posts}
Nesta terceira \textit{query}, a função que desenvolvemos tinha como objetivo obter o número
total de posts (identificando perguntas e respostas separadamente) num dado período de tempo.

Para tal, bastou-nos percorrer a árvore dos Posts e comparar as datas (por ser uma árvore binária balanceada é uma tarefa fácil) com o intervalo de tempo dado, incrementando o número de perguntas e de respostas, caso estivessem dentro desse mesmo intervalo.
Desta forma, a função devolve o seguinte:
\begin{lstlisting}[caption=Query 3 - resultado a devolver]
LONG_pair totalPost = create_long_pair(numQuestions,numAnswers); //numQuestions e numAnswers: numero de perguntas e de respostas, respetivamente
\end{lstlisting}

\subsection{Questions with Tag}
A quarta interrogação pedia que criássemos uma lista com os IDs das perguntas que, num dado intervalo de tempo, contivessem uma certa \textit{tag}, sendo que essa lista teria que ser ordenada em cronologia inversa.

Nós abordamos esta \textit{query} criando um array dinâmico, no qual colocámos os IDs das perguntas que, ao percorrer a árvore, verificamos estar dentro do intervalo de tempo dado e que continha a determinada \textit{tag}. Uma vez que dentro da estrutura dos Posts já tinhamos uma lista com as suas \textit{tags}, foi-nos fácil filtrar as perguntas que pretendíamos. Após isso, bastou apenas passar a informação presente no array (já ordenado) para uma \textit{LONG\_list}:
\begin{lstlisting}[caption=Query 4 - array dinâmico para LONG\_list]
for(int i=0; i<size; i++){
		long id = g_array_index(questionsID,long,i); //questionsID: array dinamico
		set_list(result, i, id); //result: LONG_list a devolver
}
\end{lstlisting}

\subsection{Get User Info}
Para esta quinta \textit{query}, tivemos que desenvolver funções que nos permitissem obter informações relativas a um certo utilizador, isto é, a sua \textit{Short Bio} e os IDs dos seus últimos dez Posts. Como a nossa estrutura de utilizadores continha ambas as informações, foi apenas necessário ordenar em cronologia inversa as publicações de cada utilizador e converter os dados necessários para a estrutura \textit{USER}, como pedia a interrogação:
\begin{lstlisting}[caption=Query 5 - tipo da função auxiliar e passagem para estrutura USER]
// USER get_user_info_aux(GHashTable* com_user, long id);

USER res = create_user( getUserShortBio(user),postsID);
\end{lstlisting}

\subsection{Most Voted Answers}
A sexta interrogação tinha como objetivo dar os IDs das N respostas com mais votos, em ordem decrescente do número de votos, num dado intervalo de tempo. Para tal, o grupo decidiu percorrer a árvore, inserindo num array dinâmico todos as Respostas que estivessem enquadradas na cronologia dada, ordenando posteriormente o array pelo \textit{Score} de cada Post lá inserido, sendo que este é a diferença entre os \textit{UpVotes} e os \textit{DownVotes}.
\begin{lstlisting}[caption=Query 6 - função de ordenação]
int sortByScore(Post *a, Post *b){
	int score_a = getPostScore(*a);
	int score_b = getPostScore(*b);
	return score_b - score_a;
}
\end{lstlisting}
É importante referir que, ao percorrer a árvore dos Posts, a travessia parava assim que a data da publicação se situava abaixo do limite inferior do intervalo de tempo dado, de forma a ser mais eficiente. Utilizamos esta estratégia sempre que lidamos com árvores e intervalos de tempo.
\begin{lstlisting}[caption=Interrupção da travessia nas árvores]
int dateCheck = comparaDatas(begin, end, post_date); // comparaDatas: funcao que devolve 1 caso a post_date ainda nao tenha entrado no intervalo definido por begin e end e que devolve -1 caso a post_date seja mais antiga que o limite inferior (begin) do intervalo de tempo dado

if (dateCheck == -1) return TRUE; // a funcao de iteracao g_tree_foreach interrompe se a funcao argumento do tipo GTraverseFunc devolver TRUE
\end{lstlisting}

\subsection{Most Answered Questions}
A sétima interrogação é muito idêntica à sexta \textit{query}. Pedia-nos que criássemos uma lista ordenada com as perguntas mais respondidas, num dado intervalo de tempo.

Assim sendo, a nossa abordagem foi também muito semelhante, modificando apenas a inserção de Respostas no array dinâmico (passamos a inserir as Perguntas) e a ordenação deste pelo número de respostas, em vez do seu \textit{Score}.

\subsection{Contains Word}
O objetivo da oitava \textit{query} era, dada uma palavra, devolver uma lista com os IDs das N perguntas cujos títulos a contenham, ordenados por cronologia inversa.

Para resolver esta interrogação, tivemos que percorrer a árvore dos Posts, inserindo num array dinâmico os IDs das perguntas cujos títulos contenham a palavra passada como argumento. Para verificarmos tal situação, utilizamos funções predefinidas, tais como uma adaptação nossa à \textit{strdup} e a função \textit{strstr}. Após percorrermos toda a árvore de Posts, foi apenas necessário ordenar o array em cronologia inversa das perguntas lá inseridas.
\begin{lstlisting}[caption=Query 8 - comparação do título e da palavra dada como argumento]
if(strstr(titulo,word)!=NULL ){ // word: palavra dada como argumento
	g_array_append_val(postArray,post); // funcao que coloca o post no final do array dinamico
}
\end{lstlisting}

\subsection{Both Participated}
Nesta nona interrogação, tivemos o "desafio" de, dados os IDs de dois utilizadores, devolver as últimas N perguntas (cronologia inversa) em que participaram dois utilizadores específicos. Estes podem interagir de três diferentes formas: um deles faz a pergunta e o outro a resposta (e vice-versa) e ambos responderem a uma mesma pergunta.

A abordagem que considerámos mais eficiente e mais simples de implementar foi a seguinte:
\begin{enumerate}
\item Carregar as informações dos dois utilizadores dados como argumento;
\item Iterar os dois arrays dinâmicos com os Posts de cada utilizador, trocando as respostas pela respetiva pergunta (uma vez que o enunciado pedia as perguntas em que os dois utilizadores participaram), cujo ID é representado no ficheiro XML pelo \textit{ParentID};
\item Ordenar o array do primeiro utilizador pela data em cronologia inversa;
\item Comparar os arrays e colocá-los num outro array dinâmico (como o primeiro está ordenado, este também o vai ser), de forma a filtrar as perguntas em comum;
\item Selecionar as N primeiras perguntas do novo array com as perguntas em comum.
\end{enumerate}
\begin{lstlisting}[caption=Query 9 - comparação dos dois arrays de Posts de cada utilizador]
for (int i=0; i < posts1->len; i++) {
	post1 = g_array_index(posts1, Post, i); // posts1: array de posts do primeiro utilizador
	for (int j=0; j < posts2->len; j++) {
		post2 = g_array_index(posts2, Post, j); // posts2: array de posts do primeiro utilizador
		if (getPostID(post1) == getPostID(post2)){
			id = getPostID(post1);
			g_array_append_val(aux, id); // aux: array de posts em comum
			g_array_remove_index(posts2, j); // remover do segundo array para nao voltar a passar por ele
		}
	}
}
\end{lstlisting}

\subsection{Better Answer}
A décima interrogação pedia que, dada uma determinada pergunta, obtivéssemos a melhor resposta, através da seguinte função de média ponderada:
\begin{verbatim}
(score*0.45) + (reputation*0.25) + (votes*0.2) + (comments*0.1)
\end{verbatim}
Ora, como a diferença entre os \textit{UpVotes} e os \textit{DownVotes} é igual ao Score, decidimos não utilizar o ficheiros XML dos Votes e utilizar o Score presente no ficheiro dos Posts. Os restantes parâmetros encontram-se guardados na estrutura por nós definida após ser executado o \textit{load}.

Para conseguirmos responder ao que nos foi pedido, tivemos que desenvolver funções que nos permitissem verificar que o ID do Post dado correspondia a uma pergunta e, se assim fosse, iterar a árvore dos Posts para verificar quais são respostas para essa pergunta e selecionar, então, a resposta com a maior pontuação, calculada pela média acima referida.

Um dos fatores que achamos importante para a eficiência do programa foi o facto de interrompermos a iteração da árvore dos Posts (que se encontra ordenada por data) quando a data de um Post for anterior à da pergunta dada como argumento(situação que não seria, de todo, possível). Desta forma, limitamos o número de iterações, não permitindo, portanto, que se percorra toda a estrutura quando queremos, por exemplo, ver a melhor resposta para uma pergunta recente.
A comparação que utilizamos para tal foi a seguinte (sendo que o funcionamento da função \textit{g\_tree\_foreach} foi explicada numa interrogação anterior):
\begin{lstlisting}[caption=Query 10 - interrupção da iteração da árvore]
if(strcmp(getPostDate(post),data)<0) return TRUE; //post: estrutura do Post de cada iteracao; data: data da pergunta-argumento
\end{lstlisting}

\subsection{Most Used Best Rep}
Nesta décima primeira (e última) \textit{query}, era pretendido que, dado um intervalo arbitrário de tempo, desenvolvêssemos um programa que devolvesse os IDs das N \textit{tags} mais utilizadas pelos N utilizadores com melhor reputação.

Para chegar a tal resultado, tivemos que iterar toda a tabela de Hash dos utilizadores e guardar as informações relativas a estes num array dinâmico, ordenando-o de forma decrescente pela reputação de cada utilizador. Depois percorremos os N utilizadores com melhor reputacao e, a cada um deles, fomos ao seu array de Posts e colocámos noutro array dinâmico os IDs das \textit{tags} utilizadas. Após este processo, ordenámos este mesmo array, de forma a que, com uma só travessia, pudéssemos construir um vetor dinâmico de \textit{LONG\_pair}s com o seguinte formato: (ID da \textit{tag}, número de ocorrências). Por último, foi apenas necessário ordenar esse vetor pelo número de ocorrências e retirar daí os IDs das N \textit{tags} mais usadas para uma \textit{LONG\_list}.

\begin{lstlisting}[caption=Query 11 - conversão do array de tags para um de pares e respetiva ordenação]
GArray* mSetTagsId = tagsIdToMSet(tagsId); //tagsIdToMSet: transforma cada elemento do array tagsId num par (ID,numero de ocorrencias)
g_array_sort(mSetTagsId, (GCompareFunc)sortMSet); //ordena o vetor de pares pelo numero de ocorrencias
\end{lstlisting}

%% CONCLUSÃO
\section{Conclusão}
Este projeto foi extremamente enriquecedor para o grupo, uma vez que nos permitiu trabalhar com um tipo diferente de dados, o XML, e nos ensinou a trabalhar com ele. Tivemos que nos esforçar bastante para conseguirmos atingir os objetivos estabelecidos, tendo sempre em atenção o encapsulamento do código e a sua eficiência. O trabalho permitiu-nos também aprender a desenvolver as estruturas de que precisamos, consoante as dificuldades, exigências e necessidades
que nos foram sendo impostas com o desenrolar do projeto.

Os resultados que obtivemos, ao correr o programa, foram iguais aos dos testes fornecidos pelos docentes, pelo que podemos concluir que a nossa implementação está correta. Além disso, achamos que cumprimos o objetivo de criar um programa eficiente, visto que os tempos que obtivemos para cada interrogação, utilizando os \textit{dumps} do Ubuntu e os mesmos parâmetros utilizados pelos professores nos testes, foram os seguintes (aproximadamente):
\begin{table}[h]
\centering
\caption{Tempos de Execução}
\begin{tabular}{llllllllllll}
Interrogação:        & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 \\
Tempo (em segundos): & X & X & X & X & X & X & X & X & X & X  & X 
\end{tabular}
\end{table}

O tempo de carregamento dos dados para estrutura, com os \textit{dumps} do Ubuntu, foi de XXX segundos. A nossa função \textit{clean} também está a funcionar como o esperado, como se pode comprovar pelo relatório do \textit{valgrind}:
\begin{verbatim}
PARTE DO VALGRIND DOS FREES
\end{verbatim}

Em suma, tendo em conta a eficiência e os resultados que obtivemos, podemos concluir que conseguimos atingir as metas propostas com este projeto, dado que os tempos de execução, tanto do \textit{load} como das interrogações, foram bastante positivos. Com os \textit{getters} e \textit{setters} por nós definidos para as nossas estruturas, conseguimos sempre, com a modulação e separação dos ficheiros que fizemos, respeitar o encapsulamento da informação.
\end{document}
